import{_ as t,c as l,a as d,o as a}from"./app-CPX2Gx2F.js";const i={};function r(n,e){return a(),l("div",null,e[0]||(e[0]=[d('<h1 id="vue2-与-vue3-的区别" tabindex="-1"><a class="header-anchor" href="#vue2-与-vue3-的区别"><span>vue2 与 vue3 的区别</span></a></h1><h2 id="_1、响应式原理区别" tabindex="-1"><a class="header-anchor" href="#_1、响应式原理区别"><span>1、响应式原理区别</span></a></h2><ul><li><p>vue2 通过 Object.defineProperty()来劫持对象，通过发布订阅模式对属性进行 getter 和 setter 操作</p></li><li><p>vue3 通过 ES6 的新特性 proxy 来进行代理，通过 Reflect 对数据进行操作</p></li><li><p>vue3 优点：</p><ul><li>对象可直接新增、删除属性；直接通过下标修改数组</li></ul></li></ul><h2 id="_2、diff-算法优化" tabindex="-1"><a class="header-anchor" href="#_2、diff-算法优化"><span>2、diff 算法优化</span></a></h2><ul><li><p>vue2 当数据变化时，会生成新的虚拟 DOM 树，与旧的虚拟 DOM 树进行比较，找到不同的节点，然后进行更新，这个过程是全量比较，就是同级的节点都会进行比较。缺点是比较消耗了性能，有些节点的内容是不会发生变化的。</p></li><li><p>vue3 对 DOM 树全量比较进行优化，创建虚拟 DOM 的时候，会根据 DOM 节点内容是否会发生变化，对其进行添加更新类型标记。当比较新旧 DOM 树的时候，只会比较有更新类型标记的节点。</p></li></ul><h2 id="_3、具体一些优化" tabindex="-1"><a class="header-anchor" href="#_3、具体一些优化"><span>3、具体一些优化</span></a></h2><h3 id="编译优化" tabindex="-1"><a class="header-anchor" href="#编译优化"><span>编译优化</span></a></h3><ul><li><p>编译器将模板编译成渲染函数的过程中，尽可能多的提取关键信息，用于指导生成最优代码的过程。</p></li><li><p>使用 patchFlag 标记一个元素中的动态内容</p></li><li><p>通过 Block 一种特殊的 VNode，Block 多了 dynamicChildren 属性，用于存储收集它内部所有的动态子节点，按顺序进行比较更新</p></li><li><p>遇到 v-if、v-for 等动态变化节点，其自成一个 Block，不影响外层的 Block 使用优化的更新策略，不稳定的内层 Block 实施降级策略，只进行全量更新比对</p></li></ul><h3 id="静态提升" tabindex="-1"><a class="header-anchor" href="#静态提升"><span>静态提升</span></a></h3><ul><li>编译后的代码将静态元素的 createVNode 提升，更新组件时不会重新创建 VNode，每次拿到 VNode 的引用相同(变量)，Vue 渲染器直接跳过其渲染</li></ul><h3 id="预字符串化" tabindex="-1"><a class="header-anchor" href="#预字符串化"><span>预字符串化</span></a></h3><ul><li><p>模板中存在大量连续静态的标签节点，将这些节点转化为序列化字符串，并生成一个 Static 的 VNode</p></li><li><p>优点</p><ul><li><p>避免生成多个 VNode</p></li><li><p>大块静态资源可以直接通过 innerHTML 设置，性能更佳</p></li><li><p>减少内存消耗</p></li></ul></li></ul><h2 id="_4、api-区别" tabindex="-1"><a class="header-anchor" href="#_4、api-区别"><span>4、api 区别</span></a></h2><ul><li><p>vue2 使用 options API，data、methods 等等，使得业务处理逻辑比较分散</p></li><li><p>vue3 使用 composition API(组合 API)，setup、ref、reactive、watchEffect，逻辑处理比较集中，容易维护</p></li></ul><h2 id="_5、生命周期区别" tabindex="-1"><a class="header-anchor" href="#_5、生命周期区别"><span>5、生命周期区别</span></a></h2><table><thead><tr><th>vue2 生命周期名称</th><th>vue3 生命周期名称</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td><td>组件创建之前</td></tr><tr><td>created</td><td>setup</td><td>组件创建完成</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>组件挂载之前</td></tr><tr><td>mounted</td><td>onMounted</td><td>组件挂载完成</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>数据更新，虚拟 DOM 打补丁之前</td></tr><tr><td>updated</td><td>onUpdated</td><td>数据更新，虚拟 DOM 渲染完成</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td><td>组件销毁之前</td></tr><tr><td>destroyed</td><td>onUnmounted</td><td>组件销毁后</td></tr></tbody></table>',16)]))}const h=t(i,[["render",r],["__file","vue-difference.html.vue"]]),o=JSON.parse('{"path":"/page/vue/vue-difference.html","title":"vue2 与 vue3 的区别","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1、响应式原理区别","slug":"_1、响应式原理区别","link":"#_1、响应式原理区别","children":[]},{"level":2,"title":"2、diff 算法优化","slug":"_2、diff-算法优化","link":"#_2、diff-算法优化","children":[]},{"level":2,"title":"3、具体一些优化","slug":"_3、具体一些优化","link":"#_3、具体一些优化","children":[{"level":3,"title":"编译优化","slug":"编译优化","link":"#编译优化","children":[]},{"level":3,"title":"静态提升","slug":"静态提升","link":"#静态提升","children":[]},{"level":3,"title":"预字符串化","slug":"预字符串化","link":"#预字符串化","children":[]}]},{"level":2,"title":"4、api 区别","slug":"_4、api-区别","link":"#_4、api-区别","children":[]},{"level":2,"title":"5、生命周期区别","slug":"_5、生命周期区别","link":"#_5、生命周期区别","children":[]}],"git":{"updatedTime":1739875896000,"contributors":[{"name":"linwuchang","email":"linwuchang@icourt.com","commits":2}]},"filePathRelative":"page/vue/vue-difference.md"}');export{h as comp,o as data};
