import{_ as s,c as a,a as e,o as l}from"./app-CPX2Gx2F.js";const i={};function t(o,n){return l(),a("div",null,n[0]||(n[0]=[e(`<h1 id="模块化规范" tabindex="-1"><a class="header-anchor" href="#模块化规范"><span>模块化规范</span></a></h1><p>1、模块化的作用：</p><ul><li>封装变量，防止变量污染全局作用域</li><li>避免命名冲突</li><li>更好的管理代码依赖关系</li><li>代码复用</li></ul><p>2、模块化历史：</p><ul><li>无模块化(IIFE) -&gt; CommonJS -&gt; AMD -&gt; CMD -&gt; ESModule，特殊 UMD</li></ul><h2 id="_0、iife" tabindex="-1"><a class="header-anchor" href="#_0、iife"><span>0、IIFE</span></a></h2><ul><li>IIFE（Immediately Invoked Function Expression）即立即执行函数表达式，是一种在 JavaScript 中实现模块化的方法。IIFE 的作用是保护变量的作用域，避免变量污染全局作用域。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注入对象</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1、cjs-commonjs" tabindex="-1"><a class="header-anchor" href="#_1、cjs-commonjs"><span>1、CJS-CommonJs</span></a></h2><ul><li><p>通过 module+export 去对外暴露接口，通过 require 来调用其他模块</p></li><li><p>同步加载，遇到 require 就执行代码，并等待结果返回后再继续执行</p></li></ul><h2 id="_2、amd-asynchronous-module-definition" tabindex="-1"><a class="header-anchor" href="#_2、amd-asynchronous-module-definition"><span>2、AMD-Asynchronous Module Definition</span></a></h2><ul><li><p>通过异步加载 + 允许制定回调函数 —— request.js</p></li><li><p>优点：解决了浏览器中的异步加载模块的问题</p></li><li><p>缺点：有引入成本，没有考虑按需加载</p></li></ul><h2 id="_3、cmd-工具框架-sea-js" tabindex="-1"><a class="header-anchor" href="#_3、cmd-工具框架-sea-js"><span>3、CMD 工具框架 - sea.js</span></a></h2><ul><li><p>优点：按需加载，依赖就近，性能和谐</p></li><li><p>缺点：依赖于打包，加载逻辑会实际打包到模块中，增加了模块体积</p></li></ul><h2 id="_4、esm-es6-module" tabindex="-1"><a class="header-anchor" href="#_4、esm-es6-module"><span>4、ESM - ES6 Module</span></a></h2><ul><li><p>import 导入，export 导出</p></li><li><p>优点：通过一种最统一的形态整合了 js 的模块化</p></li><li><p>缺点：本质上还是运行时的依赖分析</p></li></ul>`,16)]))}const c=s(i,[["render",t],["__file","module.html.vue"]]),u=JSON.parse('{"path":"/page/project/module.html","title":"模块化规范","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"0、IIFE","slug":"_0、iife","link":"#_0、iife","children":[]},{"level":2,"title":"1、CJS-CommonJs","slug":"_1、cjs-commonjs","link":"#_1、cjs-commonjs","children":[]},{"level":2,"title":"2、AMD-Asynchronous Module Definition","slug":"_2、amd-asynchronous-module-definition","link":"#_2、amd-asynchronous-module-definition","children":[]},{"level":2,"title":"3、CMD 工具框架 - sea.js","slug":"_3、cmd-工具框架-sea-js","link":"#_3、cmd-工具框架-sea-js","children":[]},{"level":2,"title":"4、ESM - ES6 Module","slug":"_4、esm-es6-module","link":"#_4、esm-es6-module","children":[]}],"git":{"updatedTime":1735209332000,"contributors":[{"name":"linwuchang","email":"linwuchang@icourt.com","commits":1}]},"filePathRelative":"page/project/module.md"}');export{c as comp,u as data};
